using E_BangApplication.Cache;
using E_BangDomain.ResponseDtos.Account;
using Microsoft.Extensions.Caching.Distributed;
using MyCustomMediator.Deleagate;
using MyCustomMediator.Interfaces;
using System.Diagnostics.CodeAnalysis;

namespace E_BangApplication.Pipelines
{
    public class CachingBehavior<TRequest, TResponse> : IPipeline<TRequest, TResponse>
        where TRequest : IRequest<TResponse>
        where TResponse : class, new()
    {
        private readonly IDistributedCache _cache;
        public CachingBehavior(IDistributedCache cache)
        {
            _cache = cache;
        }
        /// <summary>
        /// Processes the request through the pipeline, optionally caching the response if the request supports caching.
        /// </summary>
        /// <remarks>If the <paramref name="request"/> implements <see cref="ICacheable"/>, the method
        /// attempts to retrieve a cached response using the cache key provided by the request. If no cached response is
        /// found, the method invokes the next handler in the pipeline, caches the response, and returns it.</remarks>
        /// <param name="request">The request object to be processed.</param>
        /// <param name="next">The delegate representing the next handler in the pipeline.</param>
        /// <param name="token">A <see cref="CancellationToken"/> used to observe cancellation requests.</param>
        /// <returns>A task that represents the asynchronous operation. The task result contains the response object. If caching
        /// is enabled and a cached response exists, the cached response is returned; otherwise, the response is
        /// generated by the next handler in the pipeline.</returns>
        public async Task<TResponse> SendToPipeline(TRequest request, RequestHandlerDelegate<TResponse> next, CancellationToken token)
        {
            // Add to Cache
            if (request is ICacheable cache)
            {
                string cacheKey = cache.CacheKey;
                byte[]? cachedResponse = await _cache.GetAsync(cacheKey, token);
                if (cachedResponse == null)
                {
                    TResponse response = await next();
                    string json = System.Text.Json.JsonSerializer.Serialize(response);
                    byte[] bytes = System.Text.Encoding.UTF8.GetBytes(json);
                    await _cache.SetAsync(cacheKey, bytes, new DistributedCacheEntryOptions
                    {
                        AbsoluteExpirationRelativeToNow = cache.CacheDuration
                    }, token);
                    return response;
                }
                string jsonResponse = System.Text.Encoding.UTF8.GetString(cachedResponse);
                TResponse cachedResult = System.Text.Json.JsonSerializer.Deserialize<TResponse>(jsonResponse)!;
                return cachedResult;
            }
            return await next();
        }
    }
}